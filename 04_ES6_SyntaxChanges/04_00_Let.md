# ES6 Syntax Changes
The following chapter discusses changes to  JavaScript syntax introduced in ES6.

## Let keyword

Prior to ES6, the `var` keyword was used to declare a variable in JavaScript .However,the `var` keyword has the following limitations-


### var and type safety
Variables declared using the `var` keyword are not bound to a specific data type. In other words, variables declared with `var` keyword are dynamically typed. This means, a single variable can store values of different types.This is shown in the example below. Using the `var` keyword may lead to type safety issues. 


```html
<script>
var balance = 5000
console.log(typeof balance)
//dynamically types can be changed
balance = {message:"hello"}
console.log(typeof balance)

</script>
```

Output :

```javascript
number
object
```

### var and block scope

Variables declared using the `var` keyword have global scope. This means, a variable declared within a construct can be accessed from within any part of the JavaScript code. Consider the following example- 

<!-- example2.html -->
```html
<script>
for (var i=1;i<=5;i++){
    console.log(i);
}
console.log("after the loop i value is "+i);

</script>
```

Output of the above code will be

```javascript
1
2
3
4
5
after the loop i value is 6
```
The variable `i` is declared inside the for loop using the `var` keyword.The variable `i` has a global scope and is accessible outside the loop. However at times, there might be a need to restrict a variable's access within a block.We can not use the `var` keyword in such a case. 

ES6 introduces the `let` keyword to overcome the above two limitations.

### let and type safety
The `let` keyword binds the variable to a data type , the first time it is initialized. The variable can only store value of a specific data type. This ensures that type-safety is enforced.


<!-- example3.html -->
```html
<script>
let balance = 5000 // number type
console.log(typeof balance)

//dynamically types cannot be changed
balance = {message:"hello"} // changing number to object type
console.log(typeof balance)

</script>
```

```js
Uncaught SyntaxError: Identifier 'balance' has already been declared
```

The above example declares a variable `balance` and initializes it with an initeger value. The compiler throws an error if we try to store a object value in the variable ,`balance`.



### let and block scope
The block scope restricts a variable’s access to the block in which it is declared.Variables declared using the `let` keyword have block scope. Unlike the var keyword, the let keyword allows the script to restrict access to the variable to the nearest enclosing block.This means, a variable cannot be accessed outside the construct in which the variable is declared.

**Illustration**

<!-- example4.html -->
```html
<script>
for (let i=1;i<=5;i++){
    console.log(i);
}
console.log("after the loop i value is "+i);

</script>
```
The above example declares a variable `i` within the for loop. The compiler throws an error if we try to access the variable outside the for loop.

The output of the  code is shown below- 

```javascript
1
2
3
4
5
Uncaught ReferenceError: i is not defined
```

**Illustration**
```html
<script>
let count=100
for (let count =1;count<=10;count++){
    //inside for loop brackets ,count value starts from 1
console.log("count value inside loop is ",count);
}
//outside for loop brackets ,count value is 100
console.log("count value after loop is",count);

if(count==100){
    //inside  if brackets ,count value is 50
  let count=50;
  console.log("count inside if block",count);
}

console.log(count);
</script>
```
Output is as shown

```html
 count value inside loop is  1
 count value inside loop is  2
 count value inside loop is  3
 count value inside loop is  4
 count value inside loop is  5
 count value inside loop is  6
 count value inside loop is  7
 count value inside loop is  8
 count value inside loop is  9
 count value inside loop is  10
 count value after loop is 100
 count inside if block 50
 100

```

## let and hoisting

Variable hoisting allows the use of a variable in a JavaScript program, even before it is declared.Such variables will be initialized to `undefined` by default. So, the programmer can delay the declaration of variable .Javascript runtime will scan for variable declarations and put them to top of the block scope .Variables declared with `var` keyword get hoisted to the top of block. Consider the following example


```html
<script>
// variable company is hoisted to top , var company = undefined
console.log(company); // using variable before declaring
var company = "TutorialsPoint"; // declare and initialized here


</script>

```

Output will be

```js
undefined
```

However, variables declared using the `let` cannot be accessed before declaring. In other words, the `let` keyword does not support variable hoisting.This is shown in the example below-

```html
<script>

console.log(company)
let company= "TutorialsPoint"

</script>

```

Output is shown below

```js
 Uncaught ReferenceError: company is not defined
```
**Note** − The concept of hoisting applies to variable declaration but not variable initialization. It is recommended to always declare variables at the top of their scope (the top of global code and the top of function code), to enable the code resolve the variable’s scope.
