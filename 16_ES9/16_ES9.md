# ES9 New Features

## Asynchronous Iteration

 Normal function can be converted to a generator using `*` keyword.Similarly you can convert async function to async generator by putting an `*`.Let us see an example for the same.

 When yield and await are combined. Await cannot stop yield from returning a promise but it can stop the promise from being settled.

### Example 1:

 ```html
  <script>
     async function* load(){
         yield await Promise.resolve(1);
         yield await Promise.resolve(2);
         yield await Promise.resolve(3);


     }

     async function test(){
         for await (const val of load()){
             console.log(val)
         }
     }
    test();

    console.log('end of script')
    </script>

 ```

output:

```js
end of script
1
2
3
```

### Example 2:


```html
  <script>
    async function fntest(){
         for await (const val of [10,20,30,40]){
             console.log(val)
         }
  }
  fntest();
  console.log('end of script')
 </script>

```

output:

```js
end of script
10
20
30
40

```

## Rest/Spread Properties

The rest parameters convert the last argument passed to a function into an array.where as the spread operator turns an array into separate arguments which can be passed to a function.ES9 enables same rest and spread functionalities to Object and arrays.

### Example 1:
Following exmaple shows how to destructre object using spread operator

```html
<script>
      const student = {
          age:10,
          height:5,
          weight:50
      }

      const {age,...other} = student;
     console.log(age)
     console.log(other)

  
  </script>

```

output is shown below:

```js
10
{height: 5, weight: 50}
```

### Example 2:

```html
 <script>
    function displayStudent({age,...other}){
        console.log(age)
        console.log(other)
    }

    displayStudent({
        age:10,
        height:5,
        weight:50
    })
  
  </script>

```

```js
10
{height: 5, weight: 50}
```

### Example 3: spread operator to clone object

```html
<script>
      //spread operator
    const obj1 = {a:10,b:20}
    const obj2 = {...obj1,c:30}
    console.log(obj2)
  
  </script>

```

output is shown

```js
{a: 10, b: 20, c: 30}
```

## Promise:finally()

`finally()` provides a way for code to be run whether the promise was completed successfully or rejected.This avoids duplicating code in both the promise's then() and catch() handlers

### Syntax

```
promise.finally(function() {
   
});

promise.finally(()=> {
   
});
```

Ilustration shows if the square function  receives a negative value it will reject the promise,else it will square the input values and resolves the promise.Both cases finally is invoked.

```html

<script>
let asyncSquareFn = function(n1){
            
           return new Promise((resolve,reject)=>{
            setTimeout(()=>{
                if(n1>=0){
               resolve(n1*n1)
                }
                else reject('NOT_POSITIVE_NO')
            },3000)
        })
    }

        console.log('Start')
        
        asyncSquareFn(10)//modify to add -10
        .then(result=>{
            console.log("result is",result)
        }).catch(error=>console.log(error))
        .finally(() =>{
            console.log("inside finally")
            console.log("executes all the time")
        })

        console.log("End");
</script>

```

output is :

```js
 Start
 End
 //after 3 seconds
 result is 100
 inside finally
 executes all the time
```

## Template Literal revision

As of ES6, tagged templates conform to the rules of the following escape sequences:

1. Unicode escapes started by "\u", for example `\u2764\uFE0F`
2. Unicode code point escapes indicated by "\u{}", for example \u{2F}
3. Hexadecimal escapes started by "\x", for example \xA8
4. Octal literal escapes started by "\" and followed by one or more digits, for example \125
   
This lead to errors when we deal with tag functions

```
myTagFn`\unicode`
// Throws in older ECMAScript versions(ES6 and earlier)
// SyntaxError: malformed Unicode character escape sequence
```

//rephrase this,taken from mdn
 <!-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals -->

The feature proposal removes the syntax restriction of ECMAScript escape sequences from tagged templates.
However, illegal escape sequences must still be represented in the “cooked” representation. They will show up as undefined element in the “cooked” array:

```html
 <script>
  function myTagFn(str) {
    return { "cooked": str[0], "raw": str.raw[0] }
  }

  let result1 =myTagFn`\unicode`
  console.log(result1)

  let result2 =myTagFn`\u2764\uFE0F`
  console.log(result2)
</script>
```

output is shown below

 ```js
  {cooked: undefined, raw: "\unicode"}
  {cooked: "❤️", raw: "\u2764\uFE0F"}
 ```
## Regular Expression feature

In regular expressions , the dot operator or period is use to match a single character.Match doesnot care what the character is but skips line break characters `\n` , `\r` .

Given example matches regular expression starting with `Tutorials` and ending with `Point` in between there can be any single character.So we used the `.` in regular expression.

```js
 //matching regular characters _ ,X  between s and P
console.log(/Tutorials.Point/.test('Tutorials_Point')); //true
console.log(/Tutorials.Point/.test('TutorialsXPoint'));//true
```

Given exmaple shows if we use `\n` in the input string between `Tutorials` and `Point` the matching test method will return false.
```js
console.log(/Tutorials.Point/.test('Tutorials\nPoint')); //false
console.log(/Tutorials.Point/.test('Tutorials\rPoint')); //false
```

A  new `s` flag can be used with Regex to match line spaces.


```js
console.log(/Tutorials.Point/s.test('Tutorials\nPoint'));
console.log(/Tutorials.Point/s.test('Tutorials\rPoint'));
```