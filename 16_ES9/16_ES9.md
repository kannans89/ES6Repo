# ES9 New Features

## Asynchronous Generators and Iteration

### Asynchronous Generators
Generators can be made asynchronous by using the async keyword.The syntax for defining an async generator is given below-

```

async function* generator_name()
{
//statements
}

```

When yield and await are combined. Await cannot stop yield from returning a promise but it can stop the promise from being settled.

**Illustration**
Following example shows an async generator which returns Promise on each call to the `next()` method of generator.

```
  <script>
     async function* load(){
         yield await Promise.resolve(1);
         yield await Promise.resolve(2);
         yield await Promise.resolve(3);
     }
     

    let l = load();
    l.next().then(r=>console.log(r))
    l.next().then(r=>console.log(r))
    l.next().then(r=>console.log(r))
    l.next().then(r=>console.log(r))

</script>

```

output is :

```js
{value: 1, done: false}
{value: 2, done: false}
{value: 3, done: false}
{value: undefined, done: true}
```

### for await of loop

Asynchronous iterables cannot be iterated using the traditional `for..of` loop syntax as they return promises. ES9 introduces the `for await of` loop to support asynchronous iteration. 

The syntax for using the `for await of` loop is given below: 

```
for await (variable of iterable) {
  statement
}

```

*variable* : On each iteration a value of a different property is assigned to variable. variable may be declared with const, let, or var.
*iterable*: Object whose iterable properties are to be iterated over.

**Illustration**
The following example shows the use of for await of loop to iterate an async generator.

 ```html
  <script>
     async function* load(){
         yield await Promise.resolve(1);
         yield await Promise.resolve(2);
         yield await Promise.resolve(3);


     }

     async function test(){
         for await (const val of load()){
             console.log(val)
         }
     }
    test();

    console.log('end of script')
    </script>

 ```

The output of the above code is:

```js
end of script
1
2
3
```

**Illustration**
The following example iterates an array using the for await of loop.

```html
  <script>
    async function fntest(){
         for await (const val of [10,20,30,40]){
             console.log(val)
         }
  }
  fntest();
  console.log('end of script')
 </script>

```

The output of the above code is:

```js
end of script
10
20
30
40

```

## Rest/Spread Properties

ES9 supports the use of Rest and Spread operators with Objects.
 
### Illustration : Object and Rest Operator
The following example shows the use of rest operator with an object. The value of age property of `student` the is copied into the `age` variable while the values of the remianing properties are copied into the `other` variable using the rest syntax `...`.


```html
<script>
      const student = {
          age:10,
          height:5,
          weight:50
      }

      const {age,...other} = student;
     console.log(age)
     console.log(other)

  
  </script>

```

The output of the above code is shown below:

```js
10
{height: 5, weight: 50}
```

### Illustration: Object and Spread operator
The spread operator can be used to combine multiple objects or cloning objects.This is shown in the following example-

```html
<script>
      //spread operator
    const obj1 = {a:10,b:20}
    const obj2={c:30}
 //clone obj1
    const clone_obj={...obj1}
 //combine obj1 and obj2
    const obj3 = {...obj1,...obj2}
 
    console.log(clone_obj)
    console.log(obj3)
  
  </script>

```

The output of the above code is: 

```js
{a: 10, b: 20}
{a: 10, b: 20, c: 30}
```

## Promise:finally()

The `finally()` is executed whenever a promise is settled,regardless of its outcome. This function returns a promise.The `finally()` can be used to avoid code duplication in both the promise's then() and catch() handlers

### Syntax

```
promise.finally(function() {
   
});

promise.finally(()=> {
   
});
```

**Ilustration**
The following example declares a async function that returns the square of a positive number after a delay of 3 seconds. The function throws an error if a negative number is passed. The statements in the finally block are cexecuted in either case, whether the promise is rejected or resolved. 

```html

<script>
let asyncSquareFn = function(n1){
            
           return new Promise((resolve,reject)=>{
            setTimeout(()=>{
                if(n1>=0){
               resolve(n1*n1)
                }
                else reject('NOT_POSITIVE_NO')
            },3000)
        })
    }

        console.log('Start')
        
        asyncSquareFn(10)//modify to add -10
        .then(result=>{
            console.log("result is",result)
        }).catch(error=>console.log(error))
        .finally(() =>{
            console.log("inside finally")
            console.log("executes all the time")
        })

        console.log("End");
</script>

```

The output of the above code is :

```js
 Start
 End
 //after 3 seconds
 result is 100
 inside finally
 executes all the time
```

## Template Literal revision

As of ES6, tagged templates conform to the rules of the following escape sequences:

1. Unicode escapes started by "\u", for example `\u2764\uFE0F`
2. Unicode code point escapes indicated by "\u{}", for example \u{2F}
3. Hexadecimal escapes started by "\x", for example \xA8
4. Octal literal escapes started by "\" and followed by one or more digits, for example \125
   
This lead to errors when we deal with tag functions

```
myTagFn`\unicode`
// Throws in older ECMAScript versions(ES6 and earlier)
// SyntaxError: malformed Unicode character escape sequence
```

//rephrase this,taken from mdn
 <!-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals -->

The feature proposal removes the syntax restriction of ECMAScript escape sequences from tagged templates.
However, illegal escape sequences must still be represented in the “cooked” representation. They will show up as undefined element in the “cooked” array:

```html
 <script>
  function myTagFn(str) {
    return { "cooked": str[0], "raw": str.raw[0] }
  }

  let result1 =myTagFn`\unicode`
  console.log(result1)

  let result2 =myTagFn`\u2764\uFE0F`
  console.log(result2)
</script>
```

output is shown below

 ```js
  {cooked: undefined, raw: "\unicode"}
  {cooked: "❤️", raw: "\u2764\uFE0F"}
 ```
## Regular Expression feature

In regular expressions , the dot operator or period is use to match a single character.Match doesnot care what the character is but skips line break characters `\n` , `\r` .

Given example matches regular expression starting with `Tutorials` and ending with `Point` in between there can be any single character.So we used the `.` in regular expression.

```js
 //matching regular characters _ ,X  between s and P
console.log(/Tutorials.Point/.test('Tutorials_Point')); //true
console.log(/Tutorials.Point/.test('TutorialsXPoint'));//true
```

Given exmaple shows if we use `\n` in the input string between `Tutorials` and `Point` the matching test method will return false.
```js
console.log(/Tutorials.Point/.test('Tutorials\nPoint')); //false
console.log(/Tutorials.Point/.test('Tutorials\rPoint')); //false
```

A  new `s` flag can be used with Regex to match line spaces.


```js
console.log(/Tutorials.Point/s.test('Tutorials\nPoint'));
console.log(/Tutorials.Point/s.test('Tutorials\rPoint'));
```
